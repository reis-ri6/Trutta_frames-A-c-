# Ingestion Rules

Цей документ описує, як `repo-ingestion-agent` класифікує файли, рахує скоринги й виставляє `decision` для запису в `ingestion/ingestion-index.yaml`.

---

## 1. Класифікація: `kind`

Визначити `kind` для кожного файла:

- `doc`
  - розширення: `.md`, `.txt`, `.rst`, `.adoc`, `.docx` (якщо текстовий вміст).
- `code`
  - `.ts`, `.tsx`, `.js`, `.jsx`, `.py`, `.sql`, `.sh`, `.go`, `.rb`, `.php`, `.tf`, `.yaml`, `.yml`, `.json` (якщо це код/конфіг).
- `data`
  - `.json`, `.csv`, `.parquet`, `.ndjson` (якщо це дані/снепшоти, а не конфіг коду).
- `media`
  - `.png`, `.jpg`, `.jpeg`, `.gif`, `.svg`, `.pdf`, інші бінарні.
- `other`
  - усе інше, що не підпадає під наведене.

Якщо файл технічний шум (`.DS_Store`, кеш, build-артефакти) — одразу `kind=other` і `decision=ignore`.

---

## 2. Класифікація: `subtype`

### 2.1. Для `kind = doc`

Використовувати путь, імʼя й контент.

- `marketing`
  - слова: `pitch`, `vision`, `story`, `landing`, `promo`, `benefits`, `USP`;
  - тон: багато емоційних формулювань, мало формальних структур.
- `spec`
  - структура: секції типу `Overview`, `Scope`, `API`, `Data model`, `Use cases`;
  - є явні вимоги / контракти.
- `note`
  - чернетки, TODO, мозкові штурми, неструктурований текст.
- `legal`
  - ToS, Privacy Policy, AML/KYC, ліцензії, контракти.
- `log`
  - changelog, meeting notes із датами, історія змін.
- `other`
  - все, що не вписується в попереднє.

### 2.2. Для `kind = code`

- `snippet`
  - короткий, неповний приклад (нема entrypoint, багато `...`/коментарів).
- `script`
  - самодостатній файл, який можна запускати (CLI, job, migration).
- `template`
  - є параметризовані назви, плейсхолдери, коментарі «fill here», «TODO: project-specific».
- `infra`
  - Docker, k8s, Terraform, CI, Supabase/DB конфіги.
- `test`
  - файли в `tests/`, `__tests__/` або з назвою `*.test.*`, `*.spec.*`.
- `other`
  - усе, що не класифікується вище.

### 2.3. Для `kind = data`

- `schema_sample`
  - невеликий приклад зі структурою даних.
- `dataset_sample`
  - семпл датасету, який описує реальну/синтетичну вибірку.
- `log_export`
  - експорт логів, евентів тощо.
- `other`.

---

## 3. Скоринги: `relevance_score`, `novelty_score`, `actuality_score`

Усі значення в діапазоні `0.0–1.0`.

### 3.1. `relevance_score`

Оцінює, наскільки файл належить до екосистеми Trutta/TJM/ABC/доменів.

**Підвищують оцінку:**

- Path містить ключові слова:
  - `trutta`, `tjm`, `abc`, `sospeso`, `bread`, `vienna`, `token`, `voucher`,
    `journey`, `vendor`, `reis`, `ri6`, `city`, `guide`.
- Контент містить:
  - опис токенізації сервісів/страв,
  - travel journey / TJM,
  - ABC (анонімні покупці, комʼюніті),
  - індустріальні домени (туризм, готелі, кафе, лікарні, страви, рецепти, FDA тощо),
  - посилання на PD/VG/CONCEPT/DOMAIN з `artefact-index.yaml`.

**Знижують оцінку:**

- generic-туторіали без згадки Trutta/TJM/ABC/доменів;
- чисто технічні приклади, не привʼязані до продукту.

### 3.2. `novelty_score`

Оцінює, наскільки файл відрізняється від уже наявних.

- Дуже схожий на існуючий (майже клон тексту/коду) → `0.0–0.2`.
- Розширює існуючу тему новими кейсами/модулями → `0.5+`.
- Абсолютно новий напрям / домен → `0.7+`.

Агент має використовувати семантичну схожість (якщо доступна) + прості евристики (однакова структура/назва → низька новизна).

### 3.3. `actuality_score`

Оцінює, наскільки зміст і стек актуальні:

- Новий/поточний стек (актуальні версії бібліотек, сучасна термінологія продукту) → високо.
- Legacy-API, старі назви продуктів, deprecated-патерни → низько.

Додаткові сигнали:
- час змін файла (якщо доступний);
- посилання на нові/старі PD/VG.

---

## 4. `decision`

На основі `kind`, `subtype` і скорингів виставляється `decision`:

### 4.1. `ignore`

Файл не цікавий для документації/код-бази, не має потрапляти в пайплайни:

- кеші, тимчасові файли, build-артефакти;
- великі бінарні файли без структурного значення.

### 4.2. `archive`

Файл лишається як історичний/сервісний, але не тягнемо його в канон:

- legacy-нотатки;
- застарілі спеки;
- старі pitch-decks, що втратили актуальність;
- код, який очевидно не використовується і має низький `actuality_score`.

### 4.3. `compress_clean`

Використовується тільки для:

- `kind = doc`, `subtype = marketing`,
- або документів із великою кількістю «води», але з корисними фактами.

Мета:
- створити структурований `.clean.md` + `.summary.md`;
- потім уже canonical-агенти можуть брати `.clean.md` як сировину.

### 4.4. `promote_candidate`

Сильні кандидати в canonical-артефакти:

- `spec` для ключових модулів,
- концепти, що узгоджуються з нинішньою моделлю,
- корисні, актуальні темплейти коду / конфігів.

Умови (рекомендації):

- `relevance_score >= 0.6`
- `actuality_score >= 0.6`
- `novelty_score >= 0.3`

Якщо файл — чиста копія вже канонізованого артефакту → не `promote_candidate`, а `archive`.

---

## 5. `linked_artefact_id`

При наявності запису в `progress/artefacts/artefact-index.yaml` агент може заповнити `linked_artefact_id`.

Правила:

- Якщо шлях співпадає з canonical-шляхом з індексу — ставити відповідний `id`.
- Якщо файл явно готується під конкретний артефакт (назва/шлях/теги), можна звʼязати його з:
  - `PD-***`,
  - `VG-***`,
  - `CONCEPT-*`,
  - `DOMAIN-*`,
  - `TEMPLATE-*`.

Якщо немає впевненості — `linked_artefact_id = null`.

---

## 6. Консервативна поведінка

Якщо агент **не впевнений** у:

- `subtype`,
- значеннях скорингів,
- рішенні між `archive` і `promote_candidate`,

він має:

- виставити безпечніше значення:
  - `subtype = other`,
  - `decision = archive`;
- не заповнювати `linked_artefact_id`.

Уточнення й підняття в канон — завдання `doc-canonisation-agent` + людей.
